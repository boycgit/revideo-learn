# 场景流程（Scene Flow）

Revideo 允许你通过生成器函数（generator function）来定义场景。本节将详细介绍其工作原理，并通过几个示例帮助开发者更好地理解。强烈建议阅读 [Motion Canvas 指南](https://docs.re.video/category/motion-canvas-guide) 以获得更深入的理解。

## 场景是按顺序定义的

生成器函数是通过一系列 `yield` 语句来定义的。当你第一次调用生成器函数时，会返回第一个 yield 的值。当你再次调用时，会返回第二个 yield 的值：

```ts
function* example() {
  yield 1;
  yield 2;
  yield 3;
}

const generator = example();

console.log(generator.next().value); // 1;
console.log(generator.next().value); // 2;
console.log(generator.next().value); // 3;
```

Revideo 使用生成器函数让你能够以直观的命令式方式定义视频 - 当你思考视频应该是什么样子时，你可能会将其视为一系列具体的步骤：

- 首先，视频中心出现一个红色圆圈
- 圆圈在两秒内向右移动200像素
- 然后，圆圈从视频中消失
- 之后，停顿一秒钟

在 Revideo 中，你的代码可以相对直接地转换 - 你可以从上到下阅读场景代码来理解发生了什么：

```tsx editor
import {Circle, makeScene2D} from '@revideo/2d';
import {createRef, waitFor} from '@revideo/core';

export default makeScene2D(function* (view) {
  const circleRef = createRef<Circle>();

  // 首先，视频中心出现一个红色圆圈
  yield view.add(<Circle fill={'red'} size={100} ref={circleRef} />);

  // 圆圈在两秒内向右移动200像素
  yield* circleRef().position.x(200, 2);

  // 然后，圆圈从视频中消失
  circleRef().remove();

  // 之后，停顿一秒钟
  yield* waitFor(1);
});
```

在许多情况下，你可能想要同时执行多个动画。为此，你可以使用像 [`all`](https://docs.re.video/flow#all) 这样的流程生成器。

## `yield` vs `yield*` vs 不使用 `yield`

对于刚开始使用 Revideo 的人来说，`yield*` 和 `yield` 的区别，以及 `yield view.add` 和直接调用 `view.add` 的区别可能会造成困惑。

### `yield view.add` vs `view.add`

在查看 Revideo 的代码示例时，你可能会注意到有时使用 `yield view.add`，有时只使用 `view.add` - 这不仅限于 `view`，还适用于许多其他操作或向 `View2D` 节点之外的节点添加内容。

在操作前添加 `yield` 确保 Revideo 会等待与该操作相关的任何 Promise，比如网络请求或等待字体加载。例如，以下代码因为创建了 Promise 所以在前面加了 yield：

```tsx
yield view.add(
  <Img
    src={
      'https://revideo-example-assets.s3.amazonaws.com/revideo-logo-white.png'
    }
  />,
);
```

在上面的代码中，我们初始化了一个从互联网加载图片的 `Img` 节点。这会创建一个 Promise - 在 `view.add` 前添加 `yield` 确保代码只有在 Promise 解决（图片加载完成）后才会继续执行。

Promise 不仅仅由明显的网络请求引起。如果你添加文本节点，也可能创建 Promise，因为 Revideo 需要等待 `document.fonts.ready` 事件触发。为了安全起见，你可以对每个 `add` 调用都使用 `yield` - 这是一个好的通用做法，不会造成问题。如果你在创建 Promise 的操作前没有使用 `yield`，Revideo 会抛出警告："Tried to access an asynchronous property before the node was ready"。

### 调用 `yield` 会给视频添加额外的帧吗？

我们经常通过说每个 `yield` 对应视频中的一帧来解释 Revideo。这有助于粗略理解，但并不完全准确。只有当 yield 的值为 falsy 时，`yield` 才会对应一帧。当逐步执行生成器函数来渲染视频时，Revideo 是这样决定是否绘制帧的（伪代码）：

```ts
let result = scene.next();

// 当 yield 不为空时我们不绘制帧
while (result.value) {
  // 等待 promises
  if (isPromise(result.value)) {
    result = await result.value;

    // yield 的值应该是一个 promise；你不应该在场景中做类似 `yield 5;` 这样的操作
  } else {
    console.warn('Invalid value yielded by the scene.');
  }

  result = scene.next();
}

// 当结果为空时（while 循环通过），我们渲染一帧
drawFrame();
```

看一些场景代码的例子：

```tsx
yield view.add(<Img src={'img.png'} />); // yield 了一个 promise，我们等待它完成但不渲染帧

// 我们 yield 30个空值，对应30帧（在30fps的情况下相当于1秒视频）。这与调用 yield* waitFor(1); 相同
for (let i = 0; i < 30; i++) {
  yield;
}
```

### `yield` vs `yield*`

`yield` 用于暂停生成器的执行并返回单个值，而 `yield*` 则委托给另一个生成器函数。简单来说，你应该对单个操作使用 `yield`，而对产生多个帧的生成器使用 `yield*`：

```tsx
yield view.add(<Img src={'img.png'} />); // 不产生帧

yield* waitFor(1); // 需要时间，产生多个帧
```
